[[reference_setup]]
= Getting started

Spring Data Neo4j 4.2 (SDN 4.2) dramatically simplifies development, but some setup is naturally required.
For building the application, your build automation tool needs to be configured to include the Spring Data Neo4j dependencies and after the build setup is complete, the Spring application needs to be configured to make use of Spring Data Neo4j.
Examples for these different setups can be found in the http://github.com/neo4j-examples[Spring Data Neo4j examples].

Spring Data Neo4j projects can be built using Maven, Gradle or Ant/Ivy.

== Dependencies for Spring Data Neo4j 4.2

.Maven dependencies
[source,xml]
----
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-neo4j</artifactId>
    <version>{version}</version>
</dependency>
----

By default, SDN 4.2 will use the Http driver to connect to Neo4j and you don't need to declare it as a separate dependency in your pom.
If you want to use the embedded or Bolt drivers in your production application, you must add the following dependencies as well.
(This dependency on the embedded driver is not required if you only want to use the embedded driver for testing. See the section on <<testing,Testing>> below for more information).

[source,xml]
----
<!-- add this dependency if you want to use the embedded driver -->
<dependency>
    <groupId>org.neo4j</groupId>
    <artifactId>neo4j-ogm-embedded-driver</artifactId>
    <version>{ogm-version}</version>
</dependency>

<!-- add this dependency if you want to use the Bolt driver -->
<dependency>
    <groupId>org.neo4j</groupId>
    <artifactId>neo4j-ogm-bolt-driver</artifactId>
    <version>{ogm-version}</version>
</dependency>

----

.Gradle dependencies
[source,xml]
----
dependencies {
    compile 'org.springframework.data:spring-data-neo4j:{version}'

    # add this dependency if you want to use the embedded driver
    compile 'org.neo4j:neo4j-ogm-embedded-driver:{ogm-version}'

    # add this dependency if you want to use the Bolt driver
    compile 'org.neo4j:neo4j-ogm-bolt-driver:{ogm-version}'

}
----

.Ivy dependencies
[source,xml]
----
<dependency org="org.springframework.data" name="spring-data-neo4j" rev="{version}"/>

<!-- add this dependency if you want to use the embedded driver -->
<dependency org="org.neo4j" name="neo4j-ogm-embedded-driver" rev="{ogm-version}"/>

<!-- add this dependency if you want to use the Bolt driver -->
<dependency org="org.neo4j" name="neo4j-ogm-bolt-driver" rev="{ogm-version}"/>

----

== Spring configuration

=== JavaConfig configuration

Version 4.2 significantly reduces the complexity of configuration for the application developer.

==== Pure Java Applications

For most applications the following configuration is all that's needed to get up and running.

.Pure Java Configuration
[source,java]
----
@Configuration
@EnableNeo4jExperimentalRepositories(basePackages = "org.neo4j.example.repository")
@EnableTransactionManagement
public class MyConfiguration {

    @Bean
    public SessionFactory getSessionFactory() {
        // with domain entity base package(s)
        return new SessionFactory("org.neo4j.example.domain");
    }

	@Bean
	public Neo4jTransactionManager transactionManager() {
		return new Neo4jTransactionManager(sessionFactory());
	}

}
----

==== Spring WebMVC Applications

If you are using a Spring WebMVC application the following configuration is all that's required:

.WebMVC Configuration
[source,java]
----
@Configuration
@EnableWebMvc
@ComponentScan({"org.neo4j.example.web"})
@EnableExperimentalNeo4jRepositories("org.neo4j.example.repository")
@EnableTransactionManagement
public class WebAppContext extends WebMvcConfigurerAdapter {

	@Bean
	public OpenSessionInViewInterceptor openSessionInViewInterceptor() {
		OpenSessionInViewInterceptor openSessionInViewInterceptor = new OpenSessionInViewInterceptor();
		openSessionInViewInterceptor.setSessionFactory(sessionFactory());
		return openSessionInViewInterceptor;
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		registry.addWebRequestInterceptor(openSessionInViewInterceptor());
	}

	@Bean
	public SessionFactory sessionFactory() {
        // with domain entity base package(s)
		return new SessionFactory("org.neo4j.example.domain");
	}

    @Bean
    public Neo4jTransactionManager transactionManager() throws Exception {
        return new Neo4jTransactionManager(sessionFactory());
    }
}
----

==== Java Servlet Container based Applications

If you are using a Java Servlet 3.x+ Container you can configure a filter in Spring's `WebAppInitializer` to load SDN and
process requests through a Servlet Filter. SDN provides the `OpenSessionInViewFilter` to do this:

.Web Application Initializer
[source,java]
----
public class MyAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected void customizeRegistration(ServletRegistration.Dynamic registration) {
      registration.setInitParameter("throwExceptionIfNoHandlerFound", "true");
  }

  @Override
  protected Class<?>[] getRootConfigClasses() {
      return new Class[] {ApplicationConfiguration.class}
  }

  @Override
  protected Class<?>[] getServletConfigClasses() {
      throw new Class[] {WebConfiguration.class};
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] {"/"};
  }

  protected Filter[] getServletFilters() {
    return return new Filter[] {new OpenSessionInViewFilter()};
  }

}
----



=== Java-based bean configuration (Version 4.0.x - 4.1.x)

We recommend that your Spring context should extend the core `Neo4jConfiguration` class that comes with Spring Data Neo4j.
The example below shows how this can be done.

NOTE:   You will need to override `getSessionFactory()` and `getSession()` bean definitions to provide
the required context for your own application. This is explained in more detail below.

.Pure Java Configuration
[source,java]
----
@Configuration
@EnableNeo4jRepositories(basePackages = "org.neo4j.example.repository")
@EnableTransactionManagement
public class MyConfiguration extends Neo4jConfiguration {

    @Bean
    public SessionFactory getSessionFactory() {
        // with domain entity base package(s)
        return new SessionFactory("org.neo4j.example.domain");
    }

    // needed for session in view in web-applications
    @Bean
    @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public Session getSession() throws Exception {
        return super.getSession();
    }

}
----

== Drivers

SDN 4 provides support for connecting to Neo4j using different drivers.
As a result, the `RemoteServer` and `InProcessServer` classes from previous versions should not be used, and are no longer supported.

The following drivers are available.

- Http driver
- Embedded driver
- Bolt driver

By default, SDN will try to configure the driver from a file `ogm.properties`, which it expects to find on the classpath.
In many cases you won't want to, or will not be able to provide configuration information via a properties file.
In these cases you can configure your application programmatically instead, using a `Configuration` bean.

The following sections describe how to setup Spring Data Neo4j using both techniques.

==== Configuring the Http Driver

The Http Driver connects to and communicates with a Neo4j server over Http.
An Http Driver must be used if your application is running in client-server mode.

NOTE:   The Http Driver is the default driver for SDN and doesn't need to be explicitly declared in your pom file.

.Properties file

```
driver=org.neo4j.ogm.drivers.http.driver.HttpDriver
URI=http://user:password@localhost:7474
```

NOTE:   SDN expects the properties file to be called "ogm.properties". If you want to configure your application using a _different_ properties file, you must either set a System property or Environment variable called "ogm.properties" pointing to the alternative configuration file you want to use.


.Java Configuration

To configure the Driver programmatically, create a Configuration bean and pass it as the first argument to the SessionFactory constructor in your Spring configuration:

[source,java]
----
import org.neo4j.ogm.config.Configuration;
...

@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.http.driver.HttpDriver")
       .setURI("http://user:password@localhost:7474");
   return config;
}

@Bean
public SessionFactory getSessionFactory() {
    return new SessionFactory(getConfiguration(), <packages> );
}
----

_Note: Please see the section below describing the different ways you can pass credentials to the Http Driver_

==== Configuring the Bolt Driver

The Bolt Driver connects to and communicates with a Neo4j server via the binary Bolt protocol. If your application is running in client-server mode, you must use either the HTTP or Bolt driver.

.ogm.properties
[source, properties]
----
#Driver, required
driver=org.neo4j.ogm.drivers.bolt.driver.BoltDriver

#URI of the Neo4j database, required. If no port is specified, the default port 7687 is used. Otherwise, a port can be specified with bolt://neo4j:password@localhost:1234
URI=bolt://neo4j:password@localhost

#Connection pool size (the maximum number of sessions per URL), optional, defaults to 50
connection.pool.size=150

#Encryption level (TLS), optional, defaults to REQUIRED. Valid values are NONE,REQUIRED
encryption.level=NONE

#Trust strategy, optional, not used if not specified. Valid values are TRUST_ON_FIRST_USE,TRUST_SIGNED_CERTIFICATES
trust.strategy=TRUST_ON_FIRST_USE

#Trust certificate file, required if trust.strategy is specified
trust.certificate.file=/tmp/cert
----

.Java Configuration
[source, java]
----
Configuration configuration = new Configuration();
                configuration.driverConfiguration()
                .setDriverClassName("org.neo4j.ogm.drivers.bolt.driver.BoltDriver")
                .setURI("bolt://neo4j:password@localhost")
                .setEncryptionLevel("NONE")
                .setTrustStrategy("TRUST_ON_FIRST_USE")
                .setTrustCertFile("/tmp/cert");


new SessionFactory(configuration, packages...);
----

_Note: Please see the section below describing the different ways you can pass credentials to the HTTP/Bolt Drivers_

==== Configuring the Embedded Driver

The Embedded Driver connects directly to the Neo4j database engine.
There is no server involved, therefore no network overhead between your application code and the database.
You should use the Embedded driver if you don't want to use a client-server model, or if your application is running as a Neo4j Unmanaged Extension.

If you want to use the Embedded driver in your production application, you will need to explicitly declare the required driver dependency in your project's pom file:

[source,xml]
----
    <dependency>
      <groupId>org.neo4j</groupId>
      <artifactId>neo4j-ogm-embedded-driver</artifactId>
      <version>${ogm-version}</version>
    </dependency>
----

You can specify a permanent data store location to provide durability of your data after your application shuts down, or you can use an impermanent data store, which will only exist while your application is running.

.Properties file (permanent data store)
```
driver=org.neo4j.ogm.drivers.embedded.driver.EmbeddedDriver
URI=file:///var/tmp/graph.db
```

.Properties file (impermanent data store)
```
driver=org.neo4j.ogm.drivers.embedded.driver.EmbeddedDriver
```

.Java Configuration (permanent data store)

The same technique is used for configuring the Embedded driver as for the Http Driver.
Set up a Configuration bean and pass it as the first argument to the SessionFactory constructor:

[source,java]
----
import org.neo4j.ogm.config.Configuration;
...

@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.embedded.driver.EmbeddedDriver")
       .setURI("file:///var/tmp/graph.db");
   return config;
}

@Bean
public SessionFactory getSessionFactory() {
    return new SessionFactory(getConfiguration(), <packages> );
}
----

If you want to use an impermanent data store simply omit the URI attribute from the Configuration:

[source,java]
----
@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.embedded.driver.EmbeddedDriver");
   return config;
}
----

==== Authentication

If you are using the Http or Bolt Driver you have a number of different ways to supply credentials to the Driver Configuration.

.Properties file options:
```
# embedded in the URI
URI=http://user:password@localhost:7474

# as separate attributes
username="user"
password="password"
```

.Java Configuration options
[source,java]
----
// embedded in the driver URI
@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.http.driver.HttpDriver")
       .setURI("http://user:password@localhost:7474");
   return config;
}

// separately, as plain text credentials
@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.http.driver.HttpDriver")
       .setCredentials("user", "password")
       .setURI("http://localhost:7474");
   return config;
}


// using a Credentials instance:

@Bean
public Credentials credentials() {
    return new UsernameAndPasswordCredentials(...);
}

@Bean
public Configuration getConfiguration() {
   Configuration config = new Configuration();
   config
       .driverConfiguration()
       .setDriverClassName("org.neo4j.ogm.drivers.http.driver.HttpDriver")
       .setCredentials(credentials())
       .setURI("http://localhost:7474");
   return config;
}
----

[NOTE]
====
Currently only Basic Authentication is supported by Neo4j, so the only Credentials implementation available is `UsernameAndPasswordCredentials`
====

[[testing]]
=== Testing

.Maven dependencies for testing SDN 4 applications
[source,xml]
----
       <dependency>
           <groupId>org.springframework.data</groupId>
           <artifactId>spring-data-neo4j</artifactId>
           <version>${sdn.version}</version>
           <type>test-jar</type>
       </dependency>

       <!-- the neo4j-ogm-test jar provides access to the http and embedded drivers for testing purposes -->
       <dependency>
          <groupId>org.neo4j</groupId>
          <artifactId>neo4j-ogm-test</artifactId>
          <version>${neo4j-ogm.version}</version>
          <type>test-jar</type>
          <scope>test</scope>
      </dependency>

       <dependency>
           <groupId>org.neo4j</groupId>
            <artifactId>neo4j-kernel</artifactId>
            <version>${neo4j.version}</version>
            <type>test-jar</type>
       </dependency>

       <dependency>
            <groupId>org.neo4j.app</groupId>
            <artifactId>neo4j-server</artifactId>
            <version>${neo4j.version}</version>
            <type>test-jar</type>
       </dependency>

      <dependency>
          <groupId>org.neo4j.test</groupId>
          <artifactId>neo4j-harness</artifactId>
          <version>${neo4j.version}</version>
          <scope>test</scope>
      </dependency>
----

[NOTE]
====
Since SDN 4.1, the `InProcessServer` has been deprecated. This class was used in previous versions to set up an in-memory Http server so that you could run your tests.
This is no longer appropriate given the new Driver mechanism, and we recommend you configure an Embedded Driver (impermanent data store) for your integration tests instead.
====

== Architectural Considerations

While SDN 4 has been built from the ground up it is important to understand a little about it's architecture as it has significantly
diverged from SDN 3 and could have implications in how you design your application.

SDN 3 was monolithic in a sense that all mapping code, database drivers and Spring integrations were all in one.  SDN 4 has decided to
break these components up into:
* Drivers: At the moment these come in 3 variants: Embedded, HTTP and the binary protocol Bolt.
* The Object Graph Mapper (OGM): This is similar to an ORM in that it maps database nodes to java objects. This library is agnostic of any framework (including Spring).
* Spring Data Neo4j 4: Provides syntactic sugar and code on top of the OGM to help quickly built Spring Based Neo4j OGM apps.

Those coming from other Spring Data projects or are familiar with ORM products like JPA or Hibernate may quickly recognise this architecture.
A bulk of the heavy lifting has been moved into the OGM. The OGM's key interfaces that you will deal with regularly are the `Session` and
`SessionFactory`. It is worth understanding a little more about them:

=== SessionFactory

The `SessionFactory` is needed by SDN to create instances of `org.neo4j.ogm.session.Session` as required.
When constructed, it sets up the object-graph mapping metadata, which is then used across all `Session` objects that it creates.
As seen in the above example, the packages to scan for domain object metadata should be provided to the `SessionFactory` constructor.

Note that the session factory should typically be application-scoped.
While you can use a narrower scope for this if you like, there is typically no advantage in doing so.

=== Session

A `Session` is used to drive the object-graph mapping framework. All repository implementations are driven by the `Session`.
It keeps track of the changes that have been made to entities and their relationships.
The reason it does this is so that only entities and relationships that have changed get persisted on save, which is particularly efficient when working with large graphs.

For most request/response type applications SDN will take care of Session management for you (as defined in the Configuration section above).
If you have a batch or long running desktop type application you may want to know how you can control using the session a bit more.

==== Session caching

Once an entity is tracked by the session, reloading this entity within the scope of the same session will result in the session cache
returning the previously loaded entity. However, the subgraph in the session will expand if the entity or its related
entities retrieve additional relationships from the graph.

If you want to fetch fresh data from the graph, then this can be achieved by using a new session or clearing the current
sessions context using `org.neo4j.ogm.session.Session.clear()`.

The lifetime of the `Session` can be managed in code. For example, associated with single _fetch-update-save_ cycle or unit of work.

If your application relies on long-running sessions then you may not see changes made from other users and find yourself working with outdated objects.
On the other hand, if your sessions have too narrow a scope then your save operations can be unnecessarily expensive, as updates will be made to all objects if the session isn't aware of the those that were originally loaded.

There's therefore a trade off between the two approaches.
In general, the scope of a `Session` should correspond to a "unit of work" in your application.

