<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.docbook.org/xml/4.4/docbookx.dtd">
<chapter id="tutorial_annotations">
    <title>Decorations - Annotated Domain</title>
    <para>
        I looked at the documentation again, found a simple <ulink url="http://github.com/SpringSource/spring-data-graph-examples/tree/master/hello-worlds">Hello-World example</ulink> and tried to understand it.
        The entities were annotated with @NodeEntity, that was simple, so I added the annotation to my domain classes too.
        Relationships got their own annotation named @RelationshipEntity. Property fields should be taken care of automatically.
    </para><para>
        Ok lets put this into a test. How to assure that a field was persisted to the graph store? There seemed to be two possibilities. First was to get a
        GraphDatabaseContext injected and use its getById() method. The other one was a Finder approach which I ignored for now. Let's keep things simple.
        How to persist an entity and how to get its id? No idea. So further study of the documentation revealed that there were a bunch of methods introduced to the
        entities by the aspects. That was not obvious. But I found the two that would help me here - entity.persist() and entity.getNodeId().
    </para><para>
        So my test looked like this.
    </para><para>

    <programlisting language="java" ><![CDATA[
@Autowired GraphDatabaseContext graphDatabaseContext;

@Test public void persistedMovieShouldBeRetrievableFromGraphDb() {
    Movie forrestGump = new Movie("Forrest Gump", 1994).persist();
    Movie retrievedMovie = graphDatabaseContext.getById(forrestGump.getNodeId());
    assertEqual("retrieved movie matches persisted one",forrestGump,retrievedMovie);
    assertEqual("retrieved movie title matches","Forrest Gump",retrievedMovie.getTitle());
}

    ]]></programlisting>
    </para><para>

        That worked, cool. But what about transactions I didn't declare the test to be transactional? After further reading I learned that persist() creates an
        implicit transaction - so that was like an EntityManager would behave. Ok for me. I also learned that for more complex operations on the entities I needed
        external transactions.
        </para>
</chapter>
