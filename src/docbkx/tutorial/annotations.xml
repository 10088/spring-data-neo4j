<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.docbook.org/xml/4.4/docbookx.dtd">
<chapter id="tutorial_annotations">
    <title>Decorations - Annotated Domain</title>
    <para>
        Looking at the documentation again, we found a simple <ulink url="http://github.com/SpringSource/spring-data-graph-examples/tree/master/hello-worlds">Hello-World example</ulink> and tried to understand it.
        The entities were annotated with @NodeEntity, that was simple, so we added the annotation to our domain classes too.
        Relationships got their own annotation named @RelationshipEntity. Property fields are taken care of automatically.
    </para><para>
        It's time to put this to a test. How can we be assured that a field is persisted to the graph store? There seemed to be two possibilities. First was to get a
        GraphDatabaseContext injected and use its getById() method. The other one was a Finder approach. But let's try to keep things simple.
        How can we persist an entity and how to get its id? Looking at the documentation revealed that there are a bunch of methods introduced to the
        entities by the aspects. That's not obvious, but we found the two that would help here - entity.persist() and entity.getNodeId().
    </para><para>
        So our test looked like this.
    </para><para>

    <programlisting language="java" ><![CDATA[
@Autowired GraphDatabaseContext graphDatabaseContext;

@Test public void persistedMovieShouldBeRetrievableFromGraphDb() {
    Movie forrestGump = new Movie("Forrest Gump", 1994).persist();
    Movie retrievedMovie = graphDatabaseContext.getById(forrestGump.getNodeId());
    assertEqual("retrieved movie matches persisted one",forrestGump,retrievedMovie);
    assertEqual("retrieved movie title matches","Forrest Gump",retrievedMovie.getTitle());
}

    ]]></programlisting>
    </para><para>

        That worked! But what about transactions? We didn't declare the test to be transactional. After further reading we learned that persist() creates an
        implicit transaction - so that was like an EntityManager would behave. Ok, now we're getting somewhere. We also learned that for more complex operations on the entities we'd need
        external transactions.
        </para>
</chapter>
