<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<section>
    <title>Using annotations to define POJO entities and relationships</title>
    <para>Entities are declared using the <code>@NodeEntity</code> annotation. Relationship entities use the
        <code>@RelationshipEntity</code>
        annotation.
    </para>
    <section>
        <title>@NodeEntity: The basic building block</title>
        <para>
            The <code>@NodeEntity</code> annotation is used to declare a POJO entity to be backed by a node in the
            graph store. Simple fields on the entity are mapped by default to properties of the node. Object
            references to other NodeEntities (whether single or Collection) are mapped via relationships. If
            the annotation parameter <code>useShortNames</code> is set to false, the properties and relationship
            names used will be prepended with the class name of the entity. If the parameter <code>fullIndex</code>
            is set to true, all fields of the entity will be indexed. If the <code>partial</code>
            parameter is set to true, this entity takes part in a cross-store setting where only
            the parts of the entity not handled by JPA will be mapped to the graph store.
        </para>
        <para>Entity fields can be annotated with @GraphProperty, @RelatedTo, @RelatedToVia, @Indexed and @GraphId
        </para>
        <programlisting language="java"><![CDATA[
@NodeEntity
public class Movie {
	String title;
}
]]></programlisting>
    </section>

    <section>
        <title>@RelatedTo: Connecting NodeEntities</title>
        <para>
            Relationships to other NodeEntities are mapped to graph relationships. Those can either be single
            relationships (1:1) or multiple relationships (1:N). In most cases single relationships to other
            node entities don't have to be annotated as Spring Data Graph can extract all necessary information
            from the field using reflection. In the case of multiple relationships, the <code>elementClass</code>
            parameter of @RelatedTo must be specified because of type erasure. The <code>direction</code>
            (default OUTGOING) and <code>type</code> (inferred from field name) parameters of the annotation are
            optional.
        </para>
        <para>
            Relationships to single node entities are created when setting the field and deleted when setting it to
            null. For multi-relationships the field provides a managed collection (Set) that handles addition and
            removal of node entities and reflects those in the graph relationships.
        </para>
        <programlisting language="java"><![CDATA[
@NodeEntity
public class Movie {
	private Actor topActor;
}
@NodeEntity
public class Person {
	@RelatedTo(type = "topActor", direction = Direction.INCOMING)
	private Movie wasTopActorIn;
}
@NodeEntity
public class Actor {
	@RelatedTo(type = "ACTS_IN", elementClass = Movie.class)
	private Set<Movie> movies;
}
]]></programlisting>
    </section>

    <section>
        <title>@RelationshipEntity: Rich relationships</title>
        <para>
            To access the full data model of graph relationships, POJOs can also be annotated with
            @RelationshipEntity. Relationship entities can't be instantiated directly but are rather accessed via
            node entities, either by @RelatedToVia fields or by the <code>relateTo</code> or
            <code>getRelationshipTo</code> methods.
            Relationship entities may contain fields that are mapped to properties and two special fields that are
            annotated with @StartNode and @EndNode which point to the start and end node entities respectively. These
            fields are treated as read only fields.
        </para>
        <programlisting language="java"><![CDATA[
@RelationshipEntity
public class Role {
	@StartNode
	private Actor actor;
	@EndNode
	private Movie movie;
}
]]></programlisting>
    </section>

    <section>
        <title>@RelatedToVia: Connecting NodeEntitites via RelationshipEntities</title>
        <para>
            To provide easy programmatic access to the richer relationship entities of the data model a different
            annotation @RelatedToVia can be declared on fields of Iterables of the relationship entity type. These
            Iterables then provide read only access to instances of the entity that backs the relationship of this
            relationship type. Those instances are initialized with the properties of the relationship and the start
            and end node.
        </para>
        <programlisting language="java"><![CDATA[
@NodeEntity
public class Actor {
	@RelatedToVia(type = "ACTS_IN", elementClass = Role.class)
	private Iterable<Role> roles;
}
]]></programlisting>
    </section>
    <section>
        <title>@StartNode: Starting NodeEntity of RelationshipEntity</title>
        <para>Annotation for the start node of a relationship entity, read only.</para>
    </section>
    <section>
        <title>@EndNode: Ending NodeEntity of RelationshipEntity</title>
        <para>Annotation for the end node of a relationship entity, read only.</para>
    </section>

    <section>
        <title>@Indexed: Making entities searchable by field value</title>
        <para>The @Indexed annotation can be declared on fields that are intended to be indexed by the Neo4j
            IndexManager, triggered by value modification.
            The resulting index can be used to later retrieve nodes or relationships that contain a certain property
            value (for example a name). Often an index is used to establish the start node for a traversal.
            Indexes are accessed by a Finder for a particular NodeEntity or RelationshipEntity, created via a
            FinderFactory.
        </para>
        <para>
            GraphDatabaseContext exposes the indexes for Nodes and Relationships. Indexes can
            be named, for instance to keep separate domain concepts in separate indexes. That's why it is possible
            to specifiy an index name with the @Indexed annotation. It can also be specified at the entity level,
            this name is then the default index name for all fields of the entity. If no index name is specified,
            it defaults to the one configured with Neo4j ("node" and "relationship").
        </para>
    </section>

    <section>
        <title>@GraphTraversal</title>
        <para>The @GraphTraversal annotation leverages the delegation infrastructure used by the Spring Data Graph
            aspects. It provides dynamic fields which, when accessed, return an Iterable of NodeEntities that are
            the result of a traversal starting at the current NodeEntity. The TraversalDescription used for this
            is created by a TraversalDescriptionBuilder whose class is referred to by the <code>traversalBuilder</code>
            attribute of the annotation. The class of the expected NodeEntities is provided with the
            <code>elementClass</code> attribute.
        </para>
    </section>

    <section>
        <title>@GraphProperty: Cross-store persisted fields</title>
        <para>It is not necessary to annotate fields as they are persisted by default; all fields that contain primitive
            values are persisted directly to the graph. All fields
            convertible to String using the Spring conversion services will be stored as a string. Transient fields are
            not persisted.
            This annotation is mainly used for cross-store persistence.
        </para>
    </section>

</section>