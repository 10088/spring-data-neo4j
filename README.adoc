= Spring Data Neo4j⚡️RX

[abstract]
--
This is a work in progress project determining a possible future form of Spring Data Neo4j.
Expect the README and even more the project to change quite a lot in the future weeks.
--

== Architectural guidelines and principles

The next version of Spring Data Neo4j should be designed with the following principles in mind:

* Rely completely on the https://github.com/neo4j/neo4j-java-driver[Neo4j Java Driver], without introducing another "driver" or "transport" layer between the mapping framework and the driver.
* Immutable entities and thus full support for Kotlin's data classes right from the start.
* Work result item / record and not result set oriented, thus not reading the complete result set before the mapping starts, but make a "row" the foundation for any mapping.
This encourages generation of optimized queries, which should greatly reduce the object graph impedance mismatch we see in some projects using Neo4j-OGM.
* Follow up on the reactive story for database access in general. Being immutable and row oriented are two main requirements for making things possible.

=== Modules

So far we have identified the following modules:

* Schema: Should read a set of given classes and create a schema (Metagraph) from it
* Mapping: Should take care of hydrating from results to domain objects and dehydrating vice versa. It can depend on schema, but only as a provider for property matching
* Lifecycle: Lifecycle must not depend directly on mapping, but should only care whether an Object and its Relations are managed or not
* Querying: Generates cypher queries, depends on schema

Those will be reassembled as packages inside Spring Data Neo4j RX.
There are no short-term planes to create additional artifacts from those.

NOTE: However, we should discuss if you could try a JDK 11 only project.

=== Other principles

* Ensure that the underlying store (Neo4j) leaks as little as possible into the mapping.
  I.e. reuse `@Id` etc. and avoid adding custom variants of annotation whenever possible.

=== The embedded "problem"

Supporting the embedded use case will be solved on the drivers level.

=== Integration tests

Integration tests take more time by their very nature.
To get fast feedback we have split up the tests in unit and integration tests.
Unit tests will run when the `test` goal is issued and should have a name ending with `Test` or `Tests`.
Integration tests will get executed withing the `verify` goal and their class name have to end with `IntegrationTest` to get picked up.

== Configuration

Spring Data Neo4j RX takes a "ready to use" drivers instance and uses that.
We won't provide any additional configuration for aspects that are configurable through the driver.
We will however provide support to configure the drivers instance in Spring Boot.
The current Spring Boot Starter only configures the Neo4j-OGM transport and not the "real" driver.

Closing the driver is not the the concern of Spring Data Neo4j RX.
The lifecycle of that bean should be managed by the application.
Therefore, the starter need to take care of register the drivers instance with the application.

== Architecture

This is definitely not the last version of the architecture.
It is only meant to be a basic for discussions.

=== Package structure

.A rough outline of the current and maybe future package structure
[plantuml, width=1200]
----
@startuml
note "Implementation of Spring Data Commons SPI" as SDC_note
package "org.springframework.data.neo4j" {
package "core" {
    interface Neo4jTemplate
    package "mapping" {
        package "internal" {
            note "GraphToObjectMapping" as graphMapping
        }
        annotation Node
        annotation Property
        interface Neo4jPersistentEntity
        interface Neo4jPersistentProperty
    }
    package "session" {
        interface Neo4jSessionFactory
    }
    package "convert" {
        note "conversion support" as conversionNote
    }
}

package "repository" {
SDC_note..config
    package "config" {
        class EnableNeo4jRepository
        class Neo4jRepositoryRegistrar
        class Neo4jRepositoryConfigExtension
    }
    package "query" {
        annotation Query
    }
    package "support" {
        class Neo4jRepositoryFactoryBean
        class SimpleNeo4jRepository
        class Neo4jQueryLookupStrategy
    }
    interface Neo4jRepository
    interface ReactiveNeo4jRepository
}

core-[hidden]--->repository
}

@enduml
----

[options="header"]
|===
|Package|Comment
|core
|`Neo4jTemplate` and related classes.
|core.mapping
|Spring mapping information.
|core.mapping.internal
|Neo4j data mapping.
|core.session
|Connection to the `Driver` instance.
|core.convert
|_not used yet_  place for conversion related classes.
| |
|repository
|Repository interfaces like `Neo4jRepository`.
|repository.config
|Register all needed beans for Spring context.
|repository.query
|Place where `@Query` and other query method related annotations go in.
|repository.support
|"Glue code" like `Neo4jRepositoryFactoryBean`, `SimpleNeo4jRepository` etc.
|===

=== Architecture validation
The structure of this project can be explored as a Graph.
We use https://jqassistant.org[jQAssistant] to verify our architecture during the build.
Run the following two commands

```
./mvnw clean compile jqassistant:scan
./mvnw jqassistant:server
```

and point your browser to http://localhost:7474.

=== `SimpleNeo4jRepository` initialization
. `@EnableNeo4jRepositories` defines
 ** the `repositoryFactoryBeanClass` that defaults to `Neo4jRepositoryFactoryBean.class`. (I)
 ** `Neo4jRepositoriesRegistrar` as a configuration via the `@Import` annotation.
. `Neo4jRepositoriesRegistrar` connects `@EnableNeo4jRepositories` with `Neo4jRepositoryConfigurationExtension`.
. `Neo4jRepositoryConfigurationExtension` creates `Neo4jRepositoryFactoryBean` (the class defined (I)).
** Adds manually created `Neo4jTemplate` (as an implementation of `Neo4jOperations`) bean by setting it (`setNeo4jOperations`) in the `Neo4jRepositoryFactoryBean`. (II)
** Defines the default/fallback `RepositoryFactoryBeanClassName` as `Neo4jRepositoryFactoryBean.class.getName()` in `getRepositoryFactoryBeanClassName`.
. `Neo4jRepositoryFactoryBean` has a super constructor that gets called from the infrastructure code.
As a consequence the `neo4jOperations` property has to get set in (II) after initialization.
** Creates a new instance of `Neo4jRepositoryFactory` with the in (II) provided `Neo4jOperations` in `doCreateRepositoryFactory`.
. `Neo4jRepositoryFactory` will then create a `SimpleNeo4jRepository`.
** It does this by calling `getTargetRepositoryViaReflection` in `getTargetRepository` and providing the `neo4jOperations`.
. `SimpleNeo4jRepository` (the repository behind every user defined repository) is initialized.

=== Query execution

NOTE: This section contains the already straight-forward implemented support for custom queries via `@Query`.
The other execution paths are only drafts right now and marked with a `*`.

`Neo4jRepositoryFactory` overrides the `getQueryLookupStrategy` method to provide the `Neo4jQueryLookupStrategy`.
From our previous experience and handling in other Spring Data stores this would branch off in two (technical three) directions:

. `StringBasedNeo4jQuery` for custom Cypher queries that are provided with the `@Query` annotation.
. `*` `StringBasedNeo4jQuery` for named queries that are outsourced in property files.
. `*` `PartTreeNeo4jQuery` for derived finder methods.

All three of them will get a custom `Neo4jQueryMethod` besides `Neo4jOperations` and `QueryMethodEvaluationContextProvider` (not used yet) provided.
This is a wrapper around the `java.lang.reflect.Method` passed into the `resolveQuery` method of the `Neo4jQueryLookupStrategy` to provide additional metadata.

==== `StringBasedNeo4jQuery` execution

At the moment the implementation just takes the value of the provided `@Query` annotation by calling `getAnnotatedQuery` on the `Neo4jQueryMethod`
and executes it through the `neo4jOperations` (`Neo4jTemplate`) class.
